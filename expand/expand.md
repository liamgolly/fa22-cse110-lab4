1. JavaScript flaws
   1. The first major flaw of JavaScript is its async nature. By being fully async, this means that developers must develop their code to prevent race conditions. By doing so, the code is naturally filled with await operators, and all code ends up being paused while promises are being completed. This leads to dramatic slowdowns and code that is heavily reliant on every system. The speed of the code ends up being dependent on the slowest API. 
   2. Loose typing has many problems, and it is hard to decide on what the worst problem is. The two largest problems that I can think of is the inherent obfuscation that this feature creates and the performance overhead that this causes, although this second issue is probably overshadowed by the fact that the language is interpreted rather than compiled (and yes there are very fast compiled languages that use weak typing like the 'var' keyword in C# or the entirety of lisp). The problem of code unreadability is the same with python, where forgetting to comment a single line can have drastic consequences, and an uncommented file is completely and totally unreadable. I personally have had to translate hundreds of uncomment python files and have seen horrors beyond description when it comes to code that is fully unreadable by humans, and I can confirm that weak typing is, while a neat idea in theory as it lowers the barrier to learning a language, just a trap that encourages and facilitates the creation of unreadable and unmaintainable code. Reference: [15 lines of unhinged python code](unhinged_python.png)
   3. I personally don't have much experience with web development, but from what I have worked on I have found that the web is far more bloated than it ought to be. The practice of shooting raw Unicode or ascii strings around in JSON format could have been improved by a slightly above average 12-year-old. It is comically inefficient, however in web development it is the standard now. There are certainly countless other problems with the web platform, but this is the problem that I personally find to be the most infuriating.
2. Motivations
   1. While I truly hope that loose typing was used in JavaScript to ensure that the language would be platform independent as each platform could define their own definition of 'string' and 'int', I have a deep suspicion that the real reason that weak typing was chosen for JS is because it is a 'neat' feature that would make development in the language easier and more accessible to lower skill developers. While lowering the bar of accessibility is commendable, it is only a good idea if you are creating a language that should be used as a steppingstone for aspiring developers to use to step into the world of actual development. JavaScript is not this language however, but instead the backbone of the majority of the modern web. As a result, it is abundantly clear that many developers working in the modern web are less developed as actual programmers than for languages such as C or C++, which require a decent amount of skill to handle. This lack of skill is almost certainly the reason for the decline is quality of code since the rise of the web, and the reason for the debate surrounding software "engineers" to have such prevalence.
   2. The async nature of JS makes logical sense as the language is based on web tech. Of course, you would want everything to be async, as if you rely on an API call that isn't finished than the code will not behave as expected. While the gripes that people feel when dealing with fully async code are understandable, as it leads to difficult to debug bugs when accidently creating race conditions and dramatic performance issues, it is also the easiest solution available.
   
3. The key differences between compiled and interpreted languages is how they are executed by a computer. A compiled language is 'compiled' down to machine level binaries and creates an executable file that can be run by a pc. Meanwhile, an interpreted language instead runs each line of code one at a time. While this isn't actually how most code is run nowadays since JIT revolutionized the interpreted scene, you can think of each line of code being run separately by the computer. JavaScript is an interpreted language. By being interpreted, it is automatically not platform dependent, like an exe file would be, and is also much simpler to develop and debug as a debugger can pause without having to decode binaries, as is the case with c and gdb. There are significant drawbacks that JavaScript faces by being an interpreted language, however, and the problems that it faces can't be solved the same way that languages such as python have solved them. Interpreted languages are much slower than compiled languages. Despite what web developers say, even JIT does not come close to solving the woes faced by interpreted languages when it comes to raw execution speed. People who need actual speed while using interpreted languages, such as the numpy library for python, instead rely on compiled c binaries as this is still the only way to have actual efficiency. This is due to the very nature of interpreted languages, as users do not have access to raw memory or other low level native calls. JavaScript, as it runs on the web, cannot rely on this solution. As a result, JavaScript suffers from serious performance issues when compared to compiled languages, a tradeoff that the developers were required to make to ensure that the language was fully platform independent and the web would work on any computer.

4. I believe that that the professor has us focus on raw JS rather than frameworks as with a solid foundation in JS, we can expand to use any framework of our choice in the future, rather than locking ourselves into a single framework early in our development as JS programmers and building inherent biases early in our path to learning JS. By mastering vanilla JS first, we are able to easily switch into any framework of our choice, as all JS frameworks are built on vanilla JS. The downside of not using a framework is that the actual process of developing is going to be extended, as we will have to reinvent the wheel for many of the basics that we will implement when developing our apps.
5. This lab teaches you the basics of JS and of debugging. I think that the majority of this lab is far more simplistic than the project will be, and that the debugging tools found in the developer tab are not only platform specific (Explore q2 is impossible to complete in Firefox as the debugger is read-only) but also not fully required as VSCode and WebStorm have far more detailed debuggers, but it serves as an important step 0 for learning the JS requires to ensure that the project works.

